
// Fix: Add type definition for Google's OAuth2 TokenResponse.
declare namespace google {
  namespace accounts {
    namespace oauth2 {
      interface TokenResponse {
        access_token: string;
        expires_in: number;
        scope: string;
        token_type: string;
        [key: string]: any;
      }
    }
  }
}

import { Task } from '../types';

const parseTimeEstimateToMinutes = (timeEstimate: string): number => {
    const durationRegex = /(\d+(\.\d+)?)\s*(min|hour|hours)/i;
    const match = timeEstimate.match(durationRegex);
    if (!match) return 60; 

    const value = parseFloat(match[1]);
    const unit = match[3].toLowerCase();

    if (unit.startsWith('hour')) return value * 60;
    return value; 
};

export const listTodaysEvents = async (gapi: any, token: google.accounts.oauth2.TokenResponse) => {
    if (!gapi.client) throw new Error("GAPI client not initialized.");
    
    // Ensure calendar client is loaded
    if (!gapi.client.calendar) {
        await gapi.client.load('calendar', 'v3');
    }

    gapi.client.setToken(token);

    const today = new Date();
    const timeMin = new Date(today.getFullYear(), today.getMonth(), today.getDate()).toISOString();
    const timeMax = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 1).toISOString();

    const response = await gapi.client.calendar.events.list({
        'calendarId': 'primary',
        'timeMin': timeMin,
        'timeMax': timeMax,
        'showDeleted': false,
        'singleEvents': true,
        'maxResults': 20, // Increased limit
        'orderBy': 'startTime'
    });
    
    return response.result.items;
};

export const createEvent = async (gapi: any, token: google.accounts.oauth2.TokenResponse, task: Task) => {
    if (!gapi.client) throw new Error("GAPI client not initialized.");

    // Ensure calendar client is loaded
    if (!gapi.client.calendar) {
        await gapi.client.load('calendar', 'v3');
    }
    
    // Default to now if no start date, or use provided date
    let startDate = task.startDate ? new Date(task.startDate) : new Date();
    // If the date is in the past (or invalid) and no start date was explicitly set on the task, bump it to next hour.
    // If task.startDate IS set, we respect it even if it's in the past (user might be back-logging).
    if ((!task.startDate && isNaN(startDate.getTime())) || (!task.startDate && startDate < new Date())) {
        startDate = new Date();
        startDate.setMinutes(0, 0, 0);
        startDate.setHours(startDate.getHours() + 1);
    }

    gapi.client.setToken(token);

    const durationMinutes = parseTimeEstimateToMinutes(task.timeEstimate);
    const endDate = new Date(startDate.getTime() + durationMinutes * 60000);

    const event = {
        'summary': task.title,
        'description': `${task.description}\n\nSubtasks:\n${task.subtasks.map(st => `- [${st.completed ? 'x' : ' '}] ${st.text}`).join('\n')}\n\nGenerated by GoalForge AI`,
        'start': {
            'dateTime': startDate.toISOString(),
            'timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone,
        },
        'end': {
            'dateTime': endDate.toISOString(),
            'timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone,
        },
    };

    const response = await gapi.client.calendar.events.insert({
        'calendarId': 'primary',
        'resource': event,
    });

    return response.result;
};

// New Batch Functionality with Smart Scheduling
export const createBatchEvents = async (
    gapi: any, 
    token: google.accounts.oauth2.TokenResponse, 
    tasks: Task[], 
    onProgress?: (current: number, total: number) => void,
    startCursorDate?: Date // NEW PARAMETER
) => {
    if (!gapi.client) throw new Error("GAPI client not ready.");

    // Ensure calendar client is loaded (failsafe)
    if (!gapi.client.calendar) {
        console.log("Loading GAPI Calendar v3...");
        await gapi.client.load('calendar', 'v3');
    }
    
    const tasksToSync = tasks.filter(t => !t.googleCalendarEventId);
    
    if (tasksToSync.length === 0) return [];

    // Smart Scheduling Cursor
    let scheduleCursor: Date;
    
    if (startCursorDate) {
        scheduleCursor = new Date(startCursorDate);
    } else {
        // Default: Start tomorrow at 9:00 AM if no cursor provided
        scheduleCursor = new Date();
        scheduleCursor.setDate(scheduleCursor.getDate() + 1);
        scheduleCursor.setHours(9, 0, 0, 0);
    }

    const WORK_DAY_START = 9;
    const WORK_DAY_END = 17; // 5 PM

    const tasksWithDates = tasksToSync.map(task => {
        // If task already has a valid start date, use it.
        if (task.startDate) return task;

        // Otherwise, assign a smart date
        const assignedDate = new Date(scheduleCursor);
        
        // Move cursor forward 1 hour for the next task
        scheduleCursor.setHours(scheduleCursor.getHours() + 1);

        // If we passed the work day end, move to next day 9 AM
        if (scheduleCursor.getHours() >= WORK_DAY_END) {
            scheduleCursor.setDate(scheduleCursor.getDate() + 1);
            scheduleCursor.setHours(WORK_DAY_START, 0, 0, 0);
        }

        return {
            ...task,
            startDate: assignedDate.toISOString()
        };
    });

    const results = [];
    let processedCount = 0;

    // SEQUENTIAL EXECUTION to avoid Google API Rate Limits (403)
    for (const task of tasksWithDates) {
        try {
            const result = await createEvent(gapi, token, task);
            results.push({ taskId: task.id, eventId: result.id, status: 'success' });
        } catch (e) {
            console.error(`Failed to sync task ${task.title}`, e);
            results.push({ taskId: task.id, error: e, status: 'error' });
        }
        
        processedCount++;
        if (onProgress) {
            onProgress(processedCount, tasksWithDates.length);
        }

        // Tiny delay to be polite to the API
        await new Promise(resolve => setTimeout(resolve, 100));
    }

    return results;
};
