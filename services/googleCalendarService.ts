// Fix: Add type definition for Google's OAuth2 TokenResponse.
declare namespace google {
  namespace accounts {
    namespace oauth2 {
      interface TokenResponse {
        access_token: string;
        expires_in: number;
        scope: string;
        token_type: string;
        [key: string]: any;
      }
    }
  }
}

import { Task } from '../types';

const parseTimeEstimateToMinutes = (timeEstimate: string): number => {
    const durationRegex = /(\d+(\.\d+)?)\s*(min|hour|hours)/i;
    const match = timeEstimate.match(durationRegex);
    if (!match) return 60; 

    const value = parseFloat(match[1]);
    const unit = match[3].toLowerCase();

    if (unit.startsWith('hour')) return value * 60;
    return value; 
};

export const listTodaysEvents = async (gapi: any, token: google.accounts.oauth2.TokenResponse) => {
    if (!gapi.client?.calendar) throw new Error("GAPI calendar client not initialized.");
    gapi.client.setToken(token);

    const today = new Date();
    const timeMin = new Date(today.getFullYear(), today.getMonth(), today.getDate()).toISOString();
    const timeMax = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 1).toISOString();

    const response = await gapi.client.calendar.events.list({
        'calendarId': 'primary',
        'timeMin': timeMin,
        'timeMax': timeMax,
        'showDeleted': false,
        'singleEvents': true,
        'maxResults': 20, // Increased limit
        'orderBy': 'startTime'
    });
    
    return response.result.items;
};

export const createEvent = async (gapi: any, token: google.accounts.oauth2.TokenResponse, task: Task) => {
    if (!gapi.client?.calendar) throw new Error("GAPI calendar client not initialized.");
    
    // Default to now if no start date, or use provided date
    let startDate = task.startDate ? new Date(task.startDate) : new Date();
    // If the date is in the past (or invalid), bump it to next hour
    if (isNaN(startDate.getTime()) || startDate < new Date()) {
        startDate = new Date();
        startDate.setMinutes(0, 0, 0);
        startDate.setHours(startDate.getHours() + 1);
    }

    gapi.client.setToken(token);

    const durationMinutes = parseTimeEstimateToMinutes(task.timeEstimate);
    const endDate = new Date(startDate.getTime() + durationMinutes * 60000);

    const event = {
        'summary': task.title,
        'description': `${task.description}\n\nSubtasks:\n${task.subtasks.map(st => `- [${st.completed ? 'x' : ' '}] ${st.text}`).join('\n')}\n\nGenerated by GoalForge AI`,
        'start': {
            'dateTime': startDate.toISOString(),
            'timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone,
        },
        'end': {
            'dateTime': endDate.toISOString(),
            'timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone,
        },
    };

    const response = await gapi.client.calendar.events.insert({
        'calendarId': 'primary',
        'resource': event,
    });

    return response.result;
};

// New Batch Functionality
export const createBatchEvents = async (gapi: any, token: google.accounts.oauth2.TokenResponse, tasks: Task[]) => {
    if (!gapi.client?.calendar) throw new Error("GAPI client not ready.");
    
    // Filter out tasks already synced or without valid data, but be flexible with dates (defaulting to now if needed)
    const tasksToSync = tasks.filter(t => !t.googleCalendarEventId);
    
    if (tasksToSync.length === 0) return [];

    // Execute in parallel
    const promises = tasksToSync.map(async (task, index) => {
        // Stagger start times by 1 hour if no date provided, just for visualization in calendar
        if (!task.startDate) {
             const d = new Date();
             d.setHours(9 + index, 0, 0, 0); // Start at 9am and stack
             task.startDate = d.toISOString();
        }
        try {
            const result = await createEvent(gapi, token, task);
            return { taskId: task.id, eventId: result.id, status: 'success' };
        } catch (e) {
            console.error(`Failed to sync task ${task.title}`, e);
            return { taskId: task.id, error: e, status: 'error' };
        }
    });

    return Promise.all(promises);
};