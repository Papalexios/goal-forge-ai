
// Fix: Add type definition for Google's OAuth2 TokenResponse.
declare namespace google {
  namespace accounts {
    namespace oauth2 {
      interface TokenResponse {
        access_token: string;
        expires_in: number;
        scope: string;
        token_type: string;
        [key: string]: any;
      }
    }
  }
}

import { Task } from '../types';

const parseTimeEstimateToMinutes = (timeEstimate: string): number => {
    const durationRegex = /(\d+(\.\d+)?)\s*(min|hour|hours)/i;
    const match = timeEstimate.match(durationRegex);
    if (!match) return 60; 

    const value = parseFloat(match[1]);
    const unit = match[3].toLowerCase();

    if (unit.startsWith('hour')) return value * 60;
    return value; 
};

export const listTodaysEvents = async (gapi: any, token: google.accounts.oauth2.TokenResponse) => {
    if (!gapi.client) throw new Error("GAPI client not initialized.");
    
    // Ensure calendar client is loaded
    if (!gapi.client.calendar) {
        await gapi.client.load('calendar', 'v3');
    }

    gapi.client.setToken(token);

    const today = new Date();
    const timeMin = new Date(today.getFullYear(), today.getMonth(), today.getDate()).toISOString();
    const timeMax = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 1).toISOString();

    const response = await gapi.client.calendar.events.list({
        'calendarId': 'primary',
        'timeMin': timeMin,
        'timeMax': timeMax,
        'showDeleted': false,
        'singleEvents': true,
        'maxResults': 50, // Increased limit to capture full day
        'orderBy': 'startTime'
    });
    
    return response.result.items;
};

export const createEvent = async (gapi: any, token: google.accounts.oauth2.TokenResponse, task: Task) => {
    if (!gapi.client) throw new Error("GAPI client not initialized.");

    if (!gapi.client.calendar) {
        await gapi.client.load('calendar', 'v3');
    }
    
    let startDate = task.startDate ? new Date(task.startDate) : new Date();
    if ((!task.startDate && isNaN(startDate.getTime())) || (!task.startDate && startDate < new Date())) {
        startDate = new Date();
        startDate.setMinutes(0, 0, 0);
        startDate.setHours(startDate.getHours() + 1);
    }

    gapi.client.setToken(token);

    const durationMinutes = parseTimeEstimateToMinutes(task.timeEstimate);
    const endDate = new Date(startDate.getTime() + durationMinutes * 60000);

    const event = {
        'summary': task.title,
        'description': `${task.description}\n\nSubtasks:\n${task.subtasks.map(st => `- [${st.completed ? 'x' : ' '}] ${st.text}`).join('\n')}\n\nGenerated by GoalForge AI`,
        'start': {
            'dateTime': startDate.toISOString(),
            'timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone,
        },
        'end': {
            'dateTime': endDate.toISOString(),
            'timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone,
        },
    };

    const response = await gapi.client.calendar.events.insert({
        'calendarId': 'primary',
        'resource': event,
    });

    return response.result;
};

// Optimized Concurrent Batch Processing
export const createBatchEvents = async (
    gapi: any, 
    token: google.accounts.oauth2.TokenResponse, 
    tasks: Task[], 
    onProgress?: (current: number, total: number) => void,
    startCursorDate?: Date
) => {
    if (!gapi.client) throw new Error("GAPI client not ready.");
    if (!gapi.client.calendar) await gapi.client.load('calendar', 'v3');
    
    const tasksToSync = tasks.filter(t => !t.googleCalendarEventId);
    if (tasksToSync.length === 0) return [];

    // 1. Prepare Smart Schedule
    let scheduleCursor = startCursorDate ? new Date(startCursorDate) : new Date();
    if (!startCursorDate) {
        scheduleCursor.setDate(scheduleCursor.getDate() + 1);
        scheduleCursor.setHours(9, 0, 0, 0);
    }

    const WORK_DAY_START = 9;
    const WORK_DAY_END = 17;

    const tasksWithDates = tasksToSync.map(task => {
        if (task.startDate) return task;

        const assignedDate = new Date(scheduleCursor);
        scheduleCursor.setHours(scheduleCursor.getHours() + 1);

        if (scheduleCursor.getHours() >= WORK_DAY_END) {
            scheduleCursor.setDate(scheduleCursor.getDate() + 1);
            scheduleCursor.setHours(WORK_DAY_START, 0, 0, 0);
        }

        return { ...task, startDate: assignedDate.toISOString() };
    });

    // 2. Execute with Concurrency Control (Chunking)
    const results: any[] = [];
    const CONCURRENCY_LIMIT = 5; // Safe limit for Google API rate limiting
    let processedCount = 0;

    for (let i = 0; i < tasksWithDates.length; i += CONCURRENCY_LIMIT) {
        const chunk = tasksWithDates.slice(i, i + CONCURRENCY_LIMIT);
        
        // Process chunk in parallel
        const chunkResults = await Promise.all(chunk.map(async (task) => {
            try {
                const result = await createEvent(gapi, token, task);
                return { taskId: task.id, eventId: result.id, status: 'success' };
            } catch (e) {
                console.error(`Failed to sync task ${task.title}`, e);
                return { taskId: task.id, error: e, status: 'error' };
            }
        }));

        results.push(...chunkResults);
        processedCount += chunk.length;
        if (onProgress) onProgress(processedCount, tasksWithDates.length);

        // Small cooldown between chunks to avoid burst limits
        if (i + CONCURRENCY_LIMIT < tasksWithDates.length) {
            await new Promise(resolve => setTimeout(resolve, 250));
        }
    }

    return results;
};
